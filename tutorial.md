# Build a Real-Time Online/Offline Presence System using Pusher

**TL;DR:** [Pusher](pusher.com) is a hosted service for quickly and easily adding real-time functionality to your web, mobile, and IOT devices. In this post we'll be building an online/offline presence system using ReactJS on the client-side and server-side using Nodejs and Koa. The full code is available at this [Github repo](https://github.com/jihdeh/pushit)


### What is Real-Time?
Real-time is a level of system responsiveness that is immediate or that enables the system to keep up with some external process. If you would like to know more about real-time, [read here](https://blog.pusher.com/what-is-real-time/).


### Getting Started
First we need to create a free account at [Pusher](pusher.com), then get our API keys. You will either be promtped to create a new app or click the create new app button and a modal dialog would pop up.

[![Create your app](https://s15.postimg.org/bmkc5ceuj/Screen_Shot_2016_11_21_at_7_44_17_PM.png)](https://postimg.org/image/lwmr4l4pz/)

Once you have selected your options to create your app, your Pusher credentials would be displayed.

###### Now let's write some code:

In your React application open your `index.html` page and let's include the JavaScript Pusher library.

```html
<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Online Presence with Pusher</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body>
  <div class="container">
      <div id="app">Loading...</div>
    </div>
  <!--Include Pusher Lib -->
    <!--This exposes a global Pusher constructor -->
  <script src="https://js.pusher.com/3.2/pusher.min.js"></script>
</body>

</html>

```

What we want to achieve is to display a list of visitors IP address currently viewing our web application, and if they leave the application, they should be take out of the list without requiring us to refresh the page to see changes.

Next let's create a React Component and we'll call it App component.

```javascript
import React, {Component} from "react";

export default class App from Component{
  constructor() {
      super();
        this.state = {
          visitors: [], //store a list of visitors
      count: 0, //count number of online visitors
      visitor: null //store your user information
        }
        this.configPusher = this.configPusher.bind(this);
    }
}
```
In order to get our visitors IP addressess, we would need to use a service, in this case i would be using [IpInfo.io](https://ipinfo.io/ip).

Next we would have to open a connection to Pusher.

```javascript
const pusher = new Pusher(PUSHER_KEY, {
  authTransport: "jsonp",
  channel_name: "presence-pushit-channel",
  authEndpoint: `/api/pusher/auth/${userData.data}`,
    encrypted: true
  });
const channel = pusher.subscribe("presence-pushit-channel");
```

When creating a presence channel, the channel name must be prefixed with `presence-`. Also when subscribing a [user authentication process](https://pusher.com/docs/authenticating_users) will be triggered to grant access to users who are authorized to visit the channel.

By default Pusher makes a HTTP `GET` request to `/pusher/auth/` endpoint when a channel subscription takes place, which goes to your backend. e.g http://yourdomain.com/pusher/auth.

The HTTP request parameters contains

* socket_id
  * A unique identifier for the specific client connection to Pusher
* channel_name
  * The name of the channel being subscribed to
* callback (only when using jsonp)
  * The name of the function to be called in the script to be generated by the authentication endpoint.

If your backend is hosted somewhere else, you need to set the `authTransport` Pusher constructor option to jsonp and pass `authEndpoint` value.

However in the example above i didn't use a different domain, only because i wanted to pass the visitors public IP address as a parameter to the url to be accessible on the backend.

NOTE: A visitors IP address can also be gotten on the server side, but there are issues where the returned IP address is of the server and not of the user.

Updated Code:

```javascript
....
import axios from "axios"; //for making promise-based HTTP request

....
componentDidMount() {
  this.configPusher();
}
async configPusher() {
  let visitorList = [];
    const PUSHER_KEY = "YOUR_PUSHER_KEY";
    try {
      //get ip information
      const userData = await axios.get("https://ipinfo.io/ip");

    //user authentication procress
        const pusher = new Pusher(PUSHER_KEY, {
          authTransport: "jsonp",
            channel_name: "presence-pushit-channel",
            authEndpoint: `/api/pusher/auth/${userData.data}`,
              encrypted: true
        });
        //Subscribe to the presence channel
        const channel = pusher.subscribe("presence-pushit-channel");
}
```

When a visitor has successfully subscribed to our channel we can subscribe to [presence events](https://pusher.com/docs/client_api_guide/client_presence_channels#events) on that channel. Presence channels have some defined events that can be bound to which updates us on the status of our channel members when they leave or join.


```javascript
....
channel.bind("pusher:subscription_succeeded", (members) => {
  let visitor = members.me;
  members.each(function(member) {
    visitorList.push(member);
  });
  this.setState({
    visitors: visitorList,
    count: members.count,
    visitor
  });
});
            
```

Once a subscription has been made to our presence channel, an event is triggered returning our list of members in the callback including your information which can be accessed through `members.me`.We would discuss about where this information come from later in this tutorial.

When a visitor joins our channel an event is triggered `pusher:member_added`. The event returns the currently joined member object in the callback. In this event we would want to update our view with the new visitor and also increase the count of visitors.

```javascript
channel.bind("pusher:member_added", (member) => {
  const visitors = [...this.state.visitors]; //avoid state mutation
  const memberIndex = visitors.map(v => v.id ).indexOf(member.id);
  let updateCount = this.state.count;
    //add to array list if user doesn't already exist
  if(memberIndex < 0) {
    visitors.push(member);
    updateCount += 1;
  }
  this.setState({
    visitors,
    count: updateCount
  });
});
```

And if we want to detect when a visitor leaves our channel, either they loose internet connection, refresh the page or the close their browser tab. We can do that via the `pusher:member_removed` event handler.

```javascript
channel.bind("pusher:member_removed", (member) => {
  const visitors = [...this.state.visitors];
  let updateCount = this.state.count;
    //unsubscribe visitor
  let pusher = new Pusher(PUSHER_KEY);
  pusher.unsubscribe("presence-pushit-channel");
  const memberIndex = visitors.map(v => v.id ).indexOf(member.id);
    //remove leaving member from array list
  if(memberIndex > -1) {
    visitors.splice(memberIndex, 1);
    updateCount -= 1;
  };
  this.setState({
    visitors,
    count: updateCount
  });
});
```

Now let's get to the server-side:

The need for a server side is to check that a user subscribing to your channel has the rights to join the channel.
Also remember Pusher makes a HTTP request to an endpoint `/pusher/auth` by default, but the endpoint can be changed if your server is hosted on a different domain.

Create a file called config.js. This is where we would add our pusher keys provided to us by Pusher. These can be found on your dashboard.

`npm install pusher`

```javascript
import Pusher from "pusher";

let pusher = new Pusher({
  appId: process.env.PUSHER_APP_ID,
  key: process.env.PUSHER_APP_KEY,
  secret: process.env.PUSHER_APP_SECRET,
  encrypted: true
});

export default pusher;

```

To configure our endpoint routes. As you can see below i have added the endpoint `pusher/auth/:ip`.

```javascript
import koa from "koa";
import koaRouter from "koa-router";
import bodyParser from "koa-bodyparser";
import queryRoutes from "./query-routes";

const api = koa();
const router = koaRouter();

api.use(bodyParser());

router.get("/pusher/auth/:ip", queryRoutes.authorizeChannel);

api
  .use(router.routes())
  .use(router.allowedMethods());

export default api;

```

Now let's authenticate the user. I will be using a library called [Chance](https://www.npmjs.com/package/chance) to randomly generate names for our visitors.

```javascript
import pusher from "./config";
import Chance from "chance";
let chance = new Chance();

function* authorizeChannel() {
  try {
    const socketId = this.query.socket_id;
    const channel = this.query.channel_name;
    const callback = this.query.callback;
    const name = chance.name();
    const presenceData = {
      user_id: name,
      user_info: {
        user_ip: this.params.ip,
        name
      }
    };
    const auth = JSON.stringify(pusher.authenticate(socketId, channel, presenceData));
    const cb = callback.replace(/\"/g, "") + "(" + auth + ");";
    this.set = {
      "Content-Type": "application/javascript"
    };
    this.body = cb;
  } catch (error) {
    console.log(error)
  }
}

export default { authorizeChannel };

```

Some things to notice in the code above. The HTTP query parameter contains a `socket_id`, `callback` generated by pusher and our channel name. The callback query is only available when you're using the `authTransport` and `authEndpoint` options.

The `presenceData` object contains extra information for our user.
* user_id - unique identifier for our visitor *(required)*
* user_info
  * Extra information for our visitor, can contain name, age, location. e.t.c.

Authentication is done through `pusher.authenticate` which accepts 3 parameters, the socket_id, channel name and the visitor information.
And lastly we send back a response to the frontend.

On our frontend, we can now render our information.
```javascript
...

render() {
    const {visitors, count, visitor} = this.state;
    return (
      <div>

      <nav className="navbar navbar-default">
        <div className="container-fluid">
          <div className="navbar-header">
            <a className="navbar-brand" href="#">
              <img height="50" style={{display: "inline-block"}} src="https://avatars3.githubusercontent.com/u/739550?v=3&s=200" />
              <p style={{display: "inline-block"}}>Pusher</p>
            </a>
          </div>
        </div>
      </nav>

      <div className="container">
        <br />
        <div className="row">
          <div className="dual-list list-left col-md-5">
            <div className="well text-right" style={{background: "#fff"}}>
              <div className="row">
                <div className="col-md-12">
                  <h4>Your Details</h4>
                </div>
              </div>
              <ul className="list-group">
                { visitor ? <li className="list-group-item">
                  <p>{visitor.info.name}</p>
                  <p>{visitor.info.user_ip}</p>
                </li> :
                <li className="list-group-item">Fetching your info .... </li>}
              </ul>
            </div>
          </div>
          <div className="dual-list list-right col-md-5">
            <div className="well" style={{background: "#fff"}}>
              <div className="row">
                <div className="col-md-12">
                  <h4>Visitor IP Adresses. <small>Including yours though.</small></h4>
                </div>
              </div>
              <ul className="list-group">
              {
                visitors && visitors.length > 0 ? visitors.map((value, index) =>
                  <li className="list-group-item" key={index}>{value.info.name} - {value.info.user_ip}</li>
                ) :
                <li className="list-group-item">Loading ..... </li>
              }
              </ul>
              <p>Currently viewing: {count}</p>
            </div>
          </div>
        </div><br/><br/>
        <p style={{textAlign: "center"}}>Displays a list of users ip addresses currently visiting the page.The names
        are randomly generated.
        </p>
      </div>
    </div>
    )
  }

```

And that's it. That's all there is to setting up a presence system with [Pusher](pusher.com). Seamless integration, minimum code and you do not have to worry about scaling and maintaining your real-time infrastructure.

If you don't already have a Pusher account, sign up for one now. Check out our comprehensive [docs](https://pusher.com/docs), other [tutorials](https://pusher.com/tutorials) and setup Pusher in approxiamtely 5 minutes.

The full code for this tutorial can be found here on [Github](https://github.com/jihdeh/pushit). 
